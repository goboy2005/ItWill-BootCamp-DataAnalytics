• 시행숫자 입력시 활용하는 치환 단어 &&

SQL문장을 수행할매번 값을 끝에 값만 다르고 SQL은 같을때 계속 반복해서 결과를 봐야할때 
매우 유용하다. 예를들어 이렇게 치환변수로 대체해서  사용하면 숫자를 임으로 선택해서 입력이 가능하다.
예제
select count(*)/&&던진횟수 
 from
   (select *
        from dual
        where round(dbms_random.value(0, 1),0) = 1
        connect by level<=&던진횟수);

undefine 던진횟수를 SQL내에서 두번 입력해야하는데 한번만 입력하게 하려면
    엔퍼센트 (&)를 앞에 두개쓰고 // 뒤에 한개쓰면 됩니다. 
그런데 SQL내에서 치환변수시 사용하는 엔퍼센트(&)를 두개를 한번이라도 사용하게 되면 두번째 실행할때는 안물어보고 바로 전에 입력된 값으로 실행해버린다. 그래서 치환변수내의 내용을 비우려면 Undfine 치환변수 이름을 해줘야 합니다. 

undefine 던진횟수                                       ← 요렇게 
select count(*)/&&던진횟수 
 from
   (select *
        from dual
        where round(dbms_random.value(0, 1),0) = 1
        connect by level<=&던진횟수);



• 94. Temporary Table 임시테이블의 종류 2가지

1.on commit delete rows 옵션 :데이터를 Commit 할때까지만 보관 
2.on commit preserve rows 옵션: 데이터를 접속한 유져가 로그아웃할때까지만 보관


데이터를 영구히 database 에 저장하는게 아니라 임시로 저장하는 테이블
데이터 중에서 영구히 저장할 필요는 없고 지금 잠깐 테스트를 위해서
볼 데이터라든가 아니면 지금 현재만 필요하고 나중에는 필요하지 않는 데이터가 있는데 그 데이터를 잠깐 저장할 때 사용하는 테이블이 임시 테이블입니다.


예제1)
create global temporary table emp700
     (empno number(10),
     ename varchar2(10),
      sal     number(10))
on commit delete rows; 

insert into emp700
select empno,ename,sal
from emp; 

select * from emp700;

commit; 하면 사라져 버린다! 
DB에는 저장하기는 싫어..공간을 차지하니까…

예제2) 
create global temporary table emp800
     (empno number(10),
     ename varchar2(10),
      sal     number(10))
on commit preserve rows; 

insert into emp800
select empno,ename,sal
from emp; 

select * from emp800;

접속해제하면 정보가 사라진다…

• 95.복잡한 쿼리를 단순하게 하기1-1 (VIEW)

-as 로 일반 Table 만들고
-as 로 view 테이블 만들고 

"테이블은 아니고 데이터를 바라보는 쿼리문을 테이블처럼 하나의 object (객체) 로 생성하는 것을 말한다. 

예)
create table emp708
as    ---                                      as 다음에 나오는 쿼리문의 결과대로 emp708테이블이 생성이 된다. 
select empno,ename,sal,deptno
from emp;

select*from emp708;

emp 테이블과는 별개의 또 다른 테이블이다.. 

*emp로 시작하는 내가 만든 테이블들이 뭐가있는지 확인하는 방법, 오직 emp로만 만들어진것만.. 방금만든 708테이블
Select table_name
from user_tables
where table_name like 'EMP%';

369.Dalls 에서 근무하는 사원들의 이름과 부서위치를  출력하시오! (조인)

select e.ename,d.loc
from ename e, dept d
where e.detpno=e.depno and d.loc='DALLAS';

370.위의 결과 데이터를 담는 테이블 emp710 을 생성하시오! 
create table emp710
as                                                     
select e.ename,d.loc 
from ename e, dept d
where e.detpno=e.depno and d.loc='DALLAS';

371.숫자1번부터 10번까지의 숫자를 담는 테이블을 emp705로 생성하시오! 
create table emp705
as
select level as num1
from dual
connect by level<=10;

372.emp705의  숫자 데이터중에 임의로 아무거나 하나를 지우시오. 

delete from emp705
where num1=4;

• 95.복잡한 쿼리를 단순하게 하기1-2 (VIEW)

Create view emp801
as
select empno,ename,sal,deptno
from emp;     

아까는 테이블이라고 썻는데 이번에 우리는 View를 만들었다. View는 테이블과 다르게 별도로
데이터를 저장하고 있지 않고 그냥 바로보고있다. 그냥 이테이블을 바라보는 테이블이다. 
테이블은 데이터를 저장하지만,VIew는 데이터를 저장하지 않는다. 

설명: view는 데이터를 저장하지 않으니까 속도도 빨리지고 

update emp801
set sal=0
where ename='SCOTT';

이것은 emp801view 를 update 한거지 emp 테이블 자체를 업뎃한것은 아니다..
내가 바라보는 그래서view를 update하면 실제 테이블을 update 한거와 같은것이다. 
실제 테이블도 update됩니다….
이개념이 안잡혀있는 사람이 현업에 많다…

이게 왜 필요하냐!! 회사에 데이터중에 공개하면 안되는 데이터가 있다. 민감한 데이터는 공개하면 안된다.
민감한거 빼고 나머지는 공개하고싶다..  월급만 빼고 얼마든지 업데이트하고 조회할수 있게 
하고싶다면 어찌해야 될까? 월급 다공개하면 싸우고 난리난다.

답 : 월급만 빼고 VIEW로 생성해주면 된다!! 

create view emp809
as
select empno,ename,job,hiredate,mgr,deptno            ← view 만들때 월급(sal) 제외하고 생성을 한것 그리고
from emp;                                                                준것. 추후에 emp를 갱신하면 월급빼고는 
                                                                        정상적으로 다 update된다!! 

뷰는 방금 이야기 한것처럼..이제 뷰를 수정하면 실제 테이블 수정이 된다는거. 
보안상의 이유로 우리가 이렇게 뷰를 써요

create table emp705 
as
select level as num1 - 꼭지정을 해야줘야한다.
from dual
conncet by level<=10;

설명: 위의 level은 SQL 문과 같은 예약어여서 예약어를 테이블의 컬럼명으로 생성할수 없다. 
예약어: Select,from,where,…..

create table emp905
(select number(10),   ←이렇게 select 문으로 이름을 준거랑 똑같다...그래서 level로 하면안되 ..이름지정필수
ename varchar(10),


374.직업,직업별 토탈월급을 출력하시오(세로 출력) 

select ename,sum(sal)
from emp
group by job;

375.위의 결과를 출력하는 VIEW를 생성하시오! (VIEW 이름은 emp403) 

create view emp403
as
select job,sum(sal)                as Num1        ----- 이래야 생성 
from emp
group by job;

설명: view 생성할때 그룹함수를 사용하게 되면 컬럼별칭을 줘야합니다.

376.부서번호, (부서번호별 평균월급)을 출력하는 VIEW를 deptno_avg라는 이름으로 생성하시오! 

create view deptno_avg
as
select deptno,avg(sal) as 평균
from emp
group by deptno;

377.emp와 지금 만든 deptno_avg view 와 조인해서 
이름,월급,부서번호,부서월급 평균 

select e.ename,e.sal,e.deptno,v.평균
from emp e, deptno_avg v
where e.deptno=v.deptno;

*뷰의 장점? 1 .민감한 컬럼을 감춰서 데이터를 제공할 수 있다.
           2. 복잡한 쿼리문을 단순하게 만들 수 있다. 
                

378.이름,월급,부서번호,부서평균월급을 출력하는데 월급이 부서 평균보다 더 큰 사원들만 출력하시오

select e.ename,e.sal,e.deptno,v.부서평균월급
from emp e, deptno_avg v
where e.deptno=v.deptno and e.sal > v.부서평균월급

379.emp 테이블에서 퇴사할것 같은 사원들을 예측하기 위해 자기의 월급이 자기가 속한 직업의
평균 월급보다 더작은 사원들의 이름과 월급과 직업평균을 출력하시오! 

(view 테이블 만들고) 
create view job_avg
as

select job,avg(sal) as 직업평균
from emp
group by job;

select*from job_avg;            

select e.ename,e.sal,e.job,v.직업평균
from emp e, job_avg v 
where e.job = v.job and e.sal < v.직업평균 ;


380.직업,이름,월급,순위를 출력하는데 순위가 직업별로 각각 월급이 높은 순서대로 순위를 부여하시오! 

select ename,job,sal,dense_rank() over (partition by job order by sal desc) from emp;

위의 쿼리의 결과를 view 로 만들고 view 를 쿼리해서 순위가 1등인 사원들만 출력하시오

create view tabel WF 
as
select rank() over (partition by job order by sal desc) as 부서변월급순위 from emp;

select * 부서변월급순위 from WF;

*view 의 종류 2가지  
                                       단순 View                                             복합 view 
테이블의 갯수가                            1개                                                  2개이상
그룹함수                                 포함안됨                                                포함됨
DML 여부                             데이터 갱신 가능                                       불가능할수도,가능할수도


382.이름과 부서위치를 출력하는 VIEW를 ename_loc 라는 이름으로 생성하시오

create view ename_loc
as
select e.ename,d.loc
from ename e , dept d 
where e.deptno=d.deptno;

이건 테이블을 두개 사용해서 만들었으니 복합 뷰이다. 

select * from ename_loc


383.ename_loc 의 데이터 중에 SCOTT 의 부서위치를 WASHINGTON  철자로 바꾸시오.! 

update ename_loc
set loc='washington'
where ename='SCOTT'
이거 안된다… dept 테이블에서 변경이 안되유…

설명: 변경할수없어요. SCOTT 의 부서위치가 DALLAS 에서 WS 로 변경이 된다면 실제로 DEPT테이블의 
부서위치가 DALLAS 에서 WS 으로 변경되는거라서 SCOTT 이 아닌 다른 사원들도
DALLAS 에서 WS 으로 변경되어지므로 변경이 안되게 오라클에서 막은것입니다. 
복합뷰는 이렇게 불가능 할수도있는것이다.

(테이블 구조와 원칙상 update 안되고 해서는 안되는 것들.)

384."375"번에서 만든 emp403 view를 쿼리하고 결과를 보시오

create view emp403
as
select job,sum(sal) as 토탈
from emp
group by job;

select * from emp403;           ----- 테이블 생성된 상태

update emp403
set 토탈 =2000 
where job='SALESMAN' 

설명: 위와 같이 복합뷰(Group 함수가 포함되어있으니까) 데이터를 갱신할수 없느데 만약 토탈 월급이
갱신된다면, 실제값도 갱신해줘야 하기 때문에 갱신할수도..해서도 안된다.


385.그동안 내가 만들 view들이 뭐가 들어있는지 확인하시오!
select view_name
from user_views;

select view_name, text
from user_views;

"text" 
넣었다 뻇다..이거하면 만든 Select 문장이 나오면서 만든 테이블이 무엇인지 테이블명도 볼수 있다.
위와같이 조회하면 view를 만들었을때 사용한 테이블명도 볼 수 있습니다. 외부에서 온 데이터 분석가들은
위의 쿼리를 조회할수 있는 권한을 제한하는 경우가 많습니다. 

그래서 못보게 막아버린다.

*View 삭제 : 테이블 삭제하는것과 같다  

drop view emp809; 


• 97데이터 검색 속도를 높이기 (INDEX) 

오라클 데이터베이스의 객체(object)의 종류가 5가지

1.table : 데이터를 저장하는 기본 저장소 
2.view : 데이터를 바라보는 쿼리문  ----그저 바라만 보지요~~
3.index : 검색속도를 높이기 위한 db object
4.sequence : 순서대로 번호를 생성하는 db object
5.synonym : 테이블명에 대한 또 다른 이름 (핸드폰은 한개인데 번호가 2개) emp emp111 사실같은것

index -- SQL 튜닝을 위해 반드시 알아야 하는 db object 
                ↓
    검색속도를 높이는 기술 

설명 : 인덱스는 책으로 치면 책 앞에 나오는 목차가 인덱스 입니다.
책이 테이블이면 인덱스는 책의 목차입니다. 
목차없으면 굉장히 두꺼운 테이블을 처음부터 끝까지 다 조회를 해야합니다. 목차가 없는 상태에서 책의 내용중에
어떤 내용을 찾는다면 처음부터 끝까지 다 스캔해야할것이다.  그래서 안멈추져 또 스캇없을지도 모르잖아..그래서 계속 다찾아보는거.
목차 없을때는 검색이 오래걸리지...현업에서는 검색속도에 대한 스트레스가 크다…

예제1.이름이 SCOTT 인 사원의 이름과 월급을 출력하시오
select ename,sal
from emp
where ename='SCOTT';
           ↑
이것에 대한 목차가 있었다면 더 빠르게가능했을것         

설명: ename 에 인덱스가 없기 때문에 SCOTT을 emp 테이블에서 찾을때 처음부터 끝까지 full table 스캔했을 것이다.

create index emp_ename -------인덱스 이름 내맘대로 저장,,, 의미있게      
on emp(ename) ;         ---- 테이블명(ename); 컬럼명 

설명: 위와 같이 인덱스를 생성하면 왜 검색이 빠른것인가…. 
                    
책으로 치면 앞에 목차가 만들어져서 입니다….책으로 치면 앞에 목차가 만들어져서 입니다. 그래서 목차를 먼저 검색하고 책을 검색하면
훨씬 빠르게 원하는 데이터를 검색할 수 있기 때문입니다.

인덱스(목차) 의 구조 
소제목 + 페이지 번호 
소제목이 + ㄱㄴㄷㄹ 순서대로 검색되어있다. 훨씬 더빠르게 데이터를 검색할수 있다! 

create index emp_ename
on emp(ename);

위와 같이 ename에 목차(인덱스)를 만들면 ename을  이용해서 만든 인덱스의 구조는
컬럼명 + rowid로 구성되어 있고 
그리고 컬럼명은 ABCD 순서데로 정렬되어 인덱스(목차)를 구성합니다. 

rowid 는 그행을 대표하는 주소입니다. ---  한마디로 책의 페이지 같은것이다.! 

select rowid,ename,sal
from emp;

그주소로도 data를 검색할수 있다.
select rowid,ename,sal
from emp
where rowid='AAASIQAAHAAAAItAAA';

모든 데이터에는 rowid가 있다.

emp_ename의 인덱스의 구조를 보는 쿼리문 

select ename,rowid
from emp
where ename > ' ';

여기서 신기한걸 하나 발견해야한다...이름봐보면 order by 안썻는데 abcd 순으로 나왔따다. 

select ename,rowid
from emp;

where 절에다가 index 를 거쳐가야 abcd 순으로 슝슝 나온다. 

이건 인덱스에서 읽어온것이다. 

385.사원 테이블에 월급에 인덱스를 거시오!

create index emp_sal -------인덱스 이름 내맘대로 저장, 이름은 항상 의미있게      
on emp(sal) ;   

386.emp 테이블의 sal의 인덱스인 emp_sal의 구조를 확인하시오
select sal,rowid
from emp
where sal>0;

인덱스에서 데이터를 읽어왔기 떄문에 order by 절을 사용 안했는데 월급이 정렬이 되어서 출력되었습니다. 
목차에서 읽어온것 테이블까지 갈 필요도없다! 또한 구조를 확인하기 필요한거라 0보다 크면
2~2.5 ----2


