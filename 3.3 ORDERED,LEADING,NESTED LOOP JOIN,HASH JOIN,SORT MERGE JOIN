
우리가 SQL 튜닝을 목차대로 배우면 된다고 했다..SQL 튜닝 갯수를 인덱스 SQL 튜닝

	1. Index SQL Tunning
	2. Join SQL Tunning
	3. Subquery SQL Tunning
	4. 데이터 분석함수를 이용한 Tunning
	5. 자동 SQL Tunning

2.조인 SQL 튜닝 
SQL 튜닝의 대부분은 조인이다. 그래서 조인을 잘알아둬야 한다. 그래서 조인의 소목차를 보자.

1.nested loop조인
2.hash조인
3.Sort merge 조인
4.조인 순서의 중요성
5.Outer 조인 튜닝
6.스칼라 서브쿼리를 이용한 조인 
7.조인을 내포한 DML 문 튜닝
8.고급 조인 문장 튜닝

이렇게 8가지를 다 알고있으면 된다..왠만한 현업에가서 커버를 다 할 수가 있다..

어차피 SQL을 쓰니까.. SQL튜닝까지 잘알고있으면 일을 재밌게 할 수가 있다. 

*Nested loop 조인
우리 SQL 시간에 배웠던 조인 문법 : 1. 1999 ANSI 조인 문법 
                                                          -equi join
                                                          -non equi join
                                                          -outer join
                                                          -self join

                                               2. 오라클 조인 문법 

SQL 튜닝시간에 배우는 조인 방법 3가지?
                                                   1. Nested loop join
                                                    2.hash join
                                                    3. sort merge join

방법을 알려주겠다. 근데 문법과 방법은 다르다. 조인 방법은 그...조인을 어떻게 하겠다 라는 실행계획이야...내가 이조인 문장을 어떻게 해야 조인을 빨리 할수 있을지 이런 SQL은 빨리 할수 있을지를 아는게 조인 문장이다. 

SQL 튜닝 시간에 배우는 조인 방법 3가지? 
                                                         1.nested loop join
                                                         2.hash join
                                                         3. sort merge join

조인 방법을 왜 알아야 하는가? 조인을 바르게 할려면 알아야 합니다. 
그래서 요기 한번 문제를 통해서 조인 방법을 알려줄게요..

40.사원이름,월급,부서위치를 출력하는데 조인 순서가 어떤게 더 성능이 좋겠는가??
조인을 하려면 

1.emp -----  →  dept
2.detpt ---- →  emp 

어느 하나를 먼저 읽으면서 다른 테이블을 읽으면서 조인을 해야지?? 
그러면 1번방식이 좋을까 ? 결론은 2번 방식 더 효율이 좋다 왜냐하면 작은 테이블을 먼저 읽고 큰테이블을 이랑 조인하는게 성능이 더좋습니다. 그런데 DEPT 테이블은 4건이고 emp 테이블은 14건이기 때문에 dept 테이블을 먼저 읽는게 더 성능이 좋은것이여~~ 

select e.ename,e.sal,d.loc
from emp e ,dept d
where e.deptno=d.deptno;

41.위의 조인 문장의 실행계획을 확인해서 어느 테이블을 먼저 읽고 조인했는지 확인하시오! 

select /*+ gather_plan_statistics*/ e.ename,e.sal,d.loc
where emp e, dept d
where e.deptno=d.deptno; 

빨간 글씨의 읽는 순서를 봅시다~~~ 

우리가 주목해야 할것은 dept 부터 읽었을 것이다!!그래서 Dept 부터 읽었다는게 확인이 되는것이여..그래서 우리가 설명을 써주면 실행계획을 보면 

설명: 실행계획을 보면 dept 테이블 부터 먼저 읽고 emp 와 조인했습니다. 아주 잘한것이다.!!버퍼의 갯수가 몇개인지 봐볼까요??

조인 튜닝시 중요한 튜닝방법 2가지 ? 1.조인 순서를 조정 
                                                 2.조인 방법을 조정      
위 두가지만 알면 웬만한 조인문장을 다 튜닝할수가 있다. 그래서 우리가 이제 조인 문장 순서를 건드려보겠습니다. 

42.조인 순서를 조정하는 힌트 ? ordered 힌트 
(ordered 힌트는 from 절에서 기술한 테이블 순서데로 조인해라)

select /*+ gather_plan_statistics ordered*/ e.ename,e.sal,d.loc
where emp e, dept d
where e.deptno=d.deptno; 

ordered 해도 결과는 달라지지 않는다..하지만 조인 순서가 바뀐다..어떻게?
실행계획을 보면다..바뀌었지? emp 부터 읽었죠?? 



이번에는 emp 테이블 부터 읽었고 버퍼도 증가했다..버퍼의 갯수가 상당히 증가했다.

이거 할때는 가급적이면 데모를 한번 돌리면 좋다...안돌려도 잘되면 냅두고요..

설명: 조인순서를 emp --→ dept 순으로 변경했더니 버퍼의 개수 62개로 증가했습니다.

43.다시 위의 SQL의 조인순서를 dept ---→emp 순이 되도록 힌트를 주고 SQL을 작성하시오! 힌트를 주고 확인 사살하세요

select /*+ gather_plan_statistics ordered*/ e.ename,e.sal,d.loc
where dept d, emp e
where d.deptno=e.deptno; 



위의것은 선생님이 튜닝한것인데. 기존 ordered 방식에서 힌트를 뺴니까 매우 빨라졌다 
그이유는 앞의 있던 순서가 많아짐에 따라 앞에읽는게 커져서 느려짐 그래서 이것을 Optimizer 가 스스로 할 수 있게 뺴주었더니 빨라졌다

*조인순서 연습 : emp 와 Salgrade 테이블을 조인해서 이름과 월급과 급여등급(grade) 를 출력하시오 조인순서 성능이 좋도록 하시오!!

select /*+ gather_plan_statistics ordered*/e.ename, e.sal, s.grade
from salgrade s, emp e
where e.sal between s.sal s.losal and s.hisal ;


조인 순서를 결정하는 힌트 2가지?
                 1.ordered : from절에서 기술한 테이블 순서대로 조인해라~
                 2.Leading: Leading 힌트 안에 사용한 테이블 순서데로 조인해라~

select /*+ gather_plan_statistics leading(e s) */e.ename,e.sal,s.grade 
from salgrade s, emp e
where e.sal between s.losal and s.hisal ; 


45.emp 와 dept 테이블을 조인해서 이름과 월급과 직업과 부서위치를 출력하시오!

leading 힌트를 이용해서 순서를 정하시오! 

emp ---- →dept 

select/*+  gather_plan_statistics leading(s e)*/e.ename,e.sal,s.grade
from salgrade s, emp e
where e.sal between s.losal and s.hisal;

(이렇게 하면 s 부터 읽고 e 로 가기때문에 속도가 빨라진다)

조인 튜닝시 중요한 튜닝 방법 2가지

1.조인순서를 조정해라
                     1.ordered : from 절에서 기술한 테이블 순서대로 조인해라 
                     2.leading : leading 힌트 안에 쓴 ㅔ이블 순서데로 조인해라 


2.조인방법을 결정해라
                     1.nested loop join : 적은량의 데이터를 조인할때 유리한 조인방법
                     2.hash join: 대용량 데이터를 조인할 떄 유리한 조인방법
                     3.sort merge join: 대용량 데이터를 조인할때 유리한 조인방법
                                             hash join으로 수행지 못하는 SQL에 사용하여 
                                             튜닝함 : 힌트 use_merge 

머릿속에 저거만 딱 있으면 조인 문자 웬만한것은 다 튜닝할수가 있다.
그래서 그..조인 순서를 우리가 ordered 와 리딩으로 바꿔봤으니까..이제 조인방법을 결정해서 해볼게요 여태까지 우리가 했던 조인문장은 다 해쉬 조인으로 했었다.

근데 이 해쉬 조인 문장은 메모리를 많이 먹기때문에 작은 테이블을 할때는 쓸데없이 해쉬 조인을 하면 메모리를 과다하게 사용할 필요는 없습니다. 작은 테이블 조인 할때는 nested 조인이 되게하세요!! 그래서 nestet 조인이 되게하세요!! ---작은용량은 nested loop 이 유리

46. 45 번 쿼리의 실행계획이 nested loop 조인이 되게 힌트를 주시오!!

select/*+  gather_plan_statistics leading(s e)*/e.ename,e.sal,s.grade
from salgrade s, emp e
where e.sal between s.losal and s.hisal;

                   ↓

select/*+  gather_plan_statistics leading (e d) use_nl(e d)*/e.ename,e.sal,s.grade
from dept d, emp e
where d.dept=e.dept 

select *from table(dmbs_xplan.display_cursor(null,null,'ALLSTATS LAST)');


여기 보면 Nested loops 로 되어 있다. emp 먼저 읽고 그다음에 

설명: 해쉬조인 했을때와는 다르게 버퍼가 47개로 더 늘어났습니다.
하지만 emp와 dept 테이블이 서로 조인되는 데이터의 양이 작으므로 nested loop 조인을 사용하는게 더 바람직합니다.

47. 46번의 쿼리의 조인 문장의 실행계획이 nested loop 조인이 되도록 하는 조인순서는 dept -----emp 순이 되도록 하시오! 

select /*+  gather_plan_statistics leading (e d) use_nl(e d)*/e.ename,e.sal,s.grade
from dept d, emp e
where d.dept=e.dept 
         ↓
select /*+ gather_plan_statistics leading (d e) use_nl(d e)*/e.sal,e.job,d.loc
from dept d, emp e
where d.deptno=e.deptno ;


48.emp와 salgrade 테이블을 조인해서 이름과 월급과 급여등급(grade)를 출력하는 조인문장의 조인순서와 조인 방법을 아래와 같이 출력되게 하시오

순서 salgrade -----→emp
                    ↑         
         nested loop 조인

select /*+ gather_plan_statistics leading (s e) use _nl(s e)*/e.ename,e.sal,s.grade
from salgrade s, emp e
where e.sal between s.losal and s.hisal;

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));




여기 확인해보면 salgrade 먼저 탐색하고 그다음에 emp 를 탐색하는것을 볼수 있다.

49.이름이 SCOTT인 사원의 이름과 월급과 부서위치를 출력하는 조인 문장을 작성하시오

select e.ename,e.sal,d.loc
from emp e,dept d
where e.deptno=d.deptno and ename='SCOTT';

조건이 있을때의 조인 튜닝
50.위의 SQL 은 조인순서가 아래의 2개중에 어떤게 더 좋은 순서인가?

1.emp  ------→ dept
2.dept -------→emp

둘중 더좋은 SQL 순서가 어떤것인가? 새로운 조건인 SCOTT 이 나타났다!!
근데 이건 한건이란 말이지..그럼 이건 한건만 읽고 dept 랑 조인하러 가면되기에 emp테이블에서 먼저 이름이 SCOTT인 사원의 데이터를 1건만읽고 dept 테이블과 1번만 조인하면 된다! SCOTT 의 부서 위치만 알면 되기때문에 

아래와 같은 상황일때 조인 시도 횟수는?

1.emp -----→ dept : 14번 조인시도
2.dept -----→ emp : 4번 조인시도

각각의 여기 사원들의 부서위치를 찾으러가기 위해서 14번 조인시도를 해야한다. 근데 4번만 조인시도 하면된다 ...내가 먼저 scott 보고 dept 4개의 항목으로 들어가기 때문에 총 4번만 조인시도를 하게된다! 

51.아래의 조인문장의 조인순서는 EMP ---- → dept 로 조인하고 조인 방법은 
nested loop 조인이 되도록 힌트를 주고 튜닝하시오! 

select e.ename,e.sal,d.loc
from emp e , dept d
where e.deptno=d.deptno and e.ename = 'SCOTT';
                     ↓

select /*+ gather_plan_statistics leading (e d) use_nl(e d)*/e.ename,e.sal,d.loc
from emp e , dept d
where e.deptno=d.deptno and e.ename = 'SCOTT';

설명 : 조인문장에 조인(연결) 조건 말고 검색조건이 따로 있으면 
검색 조건으로 검색되는 건수가 몇건인지 먼저 확인을하고 그 건수가 상대쪽 테이블 보다 작다면 작은 건수를 검색하는 쪽을 먼저 읽어야 합니다. 

52.아래의 SQL조인 방법은 무조건 NESTED LOOP 조인으로 하되 조인순서는 여러분들이 직접정하시오.

select e.ename,e.sal,d.loc
from emp e, dept d
where e.deptno=d.deptno
and e.job='SALESMAN'
and d.loc='CHICAGO'

step 1 
각각의 건수를 세어본다!! 
select count(*) 
from dept
where loc='CHICAGO';
1건

select count(*)
from emp
where job='SALESMAN';
4건 

step 2 
건수가 적은것을 먼저 읽는 방향으로 힌트주고 쿼리를 짜면된다. 

select /*+ gather_plan_statistics leading (d e) use _nl(e)*/e.ename,e.sal,d.loc
from dept d, emp e
where e.empno=d.deptno

점심시간문제 53.  SQL 튜닝으로 내줄게요! 아래의 SQL이 적절한 실행계획이 나올수 있도록 튜닝하시오!

Select e.ename,e.sal,s.grade 
          from emp e, salgrade s
      where e.sal between s.losal and s.hisal
       and s.grade = 1 ;
                    
                 ↓
step 1
각각의 건수를 세어줍니다.
 select count(*)
from salgrade
where grade=1;
1건

select /*+ gather_plan_statistics leading (s e) use_nl(s e)*/ e.ename,e.sal,s.grade
from emp e , salgrade s
where e.sal between s.losal and s.hisal
and s.grade=1;

설명 : Leading 힌트에 사용했던 테이블 별칭중 두번째 별칭을 use_nl 에 기술하면 됩니다.

튜닝전: 
select /*+ gather_plan_statistics leading (s e) use_nl (e) */ e.ename,e.sal,s.grade
from emp e , salgrade s
where e.sal between s.losal and s.hisal
and s.grade=1;

leading (s e) use_nl(e) 의 뜻은 salgrade 와 emp 순으로 조인하는데 emp 와 조인할 떄 nested loop 조인해라~~ 

54.emp 와 dept 와 salgrade 를 조인해서 이름과 월급과 직업 부서위치와 급여등급을 출력하시오!

select e.ename,e.sal,d.loc 
from emp e, dept d
where e.deptno=d.deptno 
and e.sal between s.losal and s.hisal; 

select e.ename,e.sal,d.loc,s.grade
from emp e ,dept d sal

55. 위의 SQL 의 조인 순서와 방법을 아래와 같이 되게 하시오!  (3개의 조인 튜닝)

dept ----- salgrade -----emp  ← 이렇게 순서를 정하고 싶지만 dept와 salgrade가 서  
                                             로 연결고리가 없어서 이렇게하면 안된다. 
 4개            5개          14개
               
dept  ----→ emp ---- salgrade ← 연결고리가 서로 있는 테이블끼리 연결하면서 조인
                                             순서를 정해줘야 합니다. 이건 가능
          ↑                     ↑
   nested loop           nested loop

select /*+ gather_plan_statistics leading (d e s) use_nl(e) use_nl(s)*/ 
                    e.ename,e.sal,d.loc,s.grade
from emp e, dept d, salgrade s
where e.deptno = d.deptno
and e.sal between s.losal and h.hisal; 

설명 : dept --→ emp---→salgrade 으로 조인하면서 dept 와 emp와 조인할 때
nested loop join 하고 dept 와 emp 와 조인한 결과와 salgrade 와 조인할때 nested loop 조인해라! 

한번조인하고 조인한 결과와 salgrade 와 조인한다고 이해하면 됩니다!! 

자이걸 이제 알았으니까 여러분들이 해보세요!! 이번에는 

56.이번에는 아래와 같이 조인되게 하시오! 

salgrade ----       emp    -----      dept     
              ↓                  ↓ 
      nested loop            nested loop


57.answp 56번의 조인문장의 실행계획을 분석하시오! 

select /*+ gather_plan_statistics leading (s e d) use_nl(e) use_nl(d)*/ 
                             e.ename,e.sal,d.loc,s.grade
from emp e, dept d, salgrade s
where e.deptno = d.deptno
and e.sal between s.losal and s.hisal; 

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));


순서를 아는것이 중요하다….

1차로보면 3번과 4번이 연결되고/  2.에있는 nested loop 으로 돌아가고
2차로 그다음에 돌아간게 dept 로 연결되고 다시 1.에 있는 nested loop 으로 돌아간거!~
그리고 마지막으로 select 로 마무리.

총 두번의 결합과 2번의 nested loop 이 돌아간다. 

58.이름이 king 인 사원의 이름과 월급과 부서위치와 급여등급을 출력하시오! 


select e.ename,e.sal,d.loc,s.grade
from emp e, dept d, salgrade s
where e.deptno=d.deptno
and e.sal between s.losal and s.hisal
AND ename='KING' ; 

조인순서 : emp -----dept -----                     salgrade 
                       ↑
                이 두개랑 조인한 결과랑 ///       salgrade 가 조인하는것임. 

59. 위의 SQL 의 조인 순서를 아래와 같이하고 조인방법은 전부 nested loop join 되게 하시오!!!

설명 : emp 테이블에서 ename 이 KING 인 데이터가 1건이므로 1건만 읽어서 dept 테이블과 조인하고 dept 테이블 조인해서 부서위치를 가져오고 
마지막으로 salgrade 테이블 조인해서 부서위치를 가져오고 emp 와 dept 테이블과 조인한 결과가 salgrade 테이블과 조인합니다. 

select /* + gather_plan_statistics leading (e d s ) use nl_(d) use nl_(s)*/
e.ename,e.sal,d.loc,s.grade
from emp e, dept d, salgrade s
where e.deptno=d.deptno
and e.sal between s.losal and s.hisal
AND ename='KING' ; 

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));


60.CHICAGO 에서 근무하는 사원들의 이름과 부서위치와 월급과 급여등급을 출력하시오(SQL문제)

select e.ename,d.loc,e.sal,s.grade
from emp e ,dept d ,salgrade s
where e.deptno=d.deptno 
and e.sal between s.losal and s.hisal
and d.loc='CHICAGO';

61.위의 SQL의 조인 방법은 전부 nested loop 조인으로 하되 조인 순서를 직접줘서 튜닝하시오!! 

조인순서를: 일단 정해놓고 가면 좋다. chicago 한번이니까 
dept =====emp =======salgrade 

크기로만 보면 dept 다음 salgrade 인데 접점이 없어서 저 순서로 가야한다. 

select /* + gather_plan_statistics leading (d e s ) use_nl(e) use_nl(s)*/  ---여기주의
e.ename,e.sal,d.loc,s.grade
from emp e ,dept d ,salgrade s
where e.deptno=d.deptno 
and e.sal between s.losal and s.hisal
and d.loc='CHICAGO';

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));

62.부서위치,부서위치별 토탈월급을 출력하시오

select d.loc,sum(e.sal)
from emp e, dept d
where e.deptno=d.deptno
group by d.loc;

63.위의 SQL의 조인 순서와 조인방법을 기술하고 수행하시오!
조인순서

dept====emp

select /*+ gather_plan_statistics leading (d e) use_nl(e)*/ d.loc,sum(e.sal)
from emp e, dept d
where e.deptno=d.deptno
group by d.loc;

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));

*HASH Join
nested loop 조인은 순차적 반복 조인으로 한 레코드씩 순차적으로 
조인을 진행하는 특정이 있습니다.

select e.ename,d.loc
from emp e , dept d
where e.deptno=d.deptno and e.job ='SALESMAN';



애네들이 어디 부서에서 일하는지 한명씩 가서 확인을 한다.
그래서 대량의 데이터를 처리하게되면 성능이 느려진다는 단점이 존재한다.
순차적으로 하나씩 처리하다 보니..처음에는 martin의 데이터로 조인하고
그 다음은 allen / turner 이런식으로 하나씩 처리하다보니 조인하려는 데이터의 양이 많으면 성능이 너무 느립니다. 에전에 오라클 뿐만 아니라 모든 데이터 베이스 시스템에서 가지고 있는 문제였는데...근데 바로 이기술 때문에 오라클이 데이터 소프트웨어가 1위가 되었다. 그래서 어…

순차적 반복을 여러 번 반복해야 하므로 비효율적 입니다.
그래서 그..대량의 데이터를 조인할 때는 nested loop 조인 보다는 hash 조인을 사용하는 것이 훨씬 성능이 좋습니다. 
hash 조인은 무엇이냐..해쉬 조인은 해쉬 알고리즘을 이용해서 데이터를 메모리에 올려놓고 메모리에서 조인하는 조인방법입니다.
메모리가 디스크보다 훨씬 빠르게 때문에…

메모리는 크기가 아주 작기때문에 서로 메모리에 데이터 올려놓고 조인하겠다고 하면 경합이 걸려서 다같이 느려집니다. 

대용량 메모리를 조인할때는 HASH 조인을 해주자.

예제
select /*+ gather_plan_statistics leading(d e) use_hash(e)*/
e.ename , e.loc
from emp e ,dept d
where e.deptno=d.deptno 


해쉬조인이 된것을 볼수 있다.

HASH JOIN

dept 테이블과 emp 테이블이 둘다 메모리로 올라가는데 메모리에한번에  올라가는데
둘다 한번에 다 올라가서 조인을 하면 너무 좋을 텐데 그렇게는 안되고
둘중에 하나만 먼저 메모리로 올리고 그리고 다른 테이블은 데이터의 일부를 조금씩 메모리로 올리면서 조인을 합니다. 

어느 파일에 어느 블럭에 있다라는 물리적 주소 정보
dept 테이블이 디스크에 있을때는 이 주소가 유용했는데
dept 테이블이 통채로 메모리로 올라가면(이사가면)위의 주소가 필요없어지고 새로운 주소가 필요한데 그주소 메모리의 주소입니다. 

메모리로 이사를가고 emp 테이블은 
그위치를 알려면 주소를 알아야하는데 이주소가 바뀌었는데...이것을 해쉬함수라는 특별한 기술을 만들어냈다. 이 해쉬함수를 통해서 메모리 주소를 알아낸다..
이해쉬 함수 알고리즘은 아무도 모르고...절대 공개하지 않아요..이알고리즘 떄문에 오라클이 부우우자가 되었다 호호호하하하 

조인을 하는데 이렇게 메모리로 올라가는 테이블을 Hash table 이라고 한다.

Hash join
Table acess full dept ---hash table(메모리로 올라간 테이블
table acess full emp ---- probe table(디스크에 있는 테이블) 

메모리가 공간이 작으니까.. emp와 dept 테이블 중에 어떤것을 메모리에 올려야겠어?
메모리의 작은 테이블인 dept 를 올려야 됩니다. 만약에 큰테이블을 올리면 성능이 너무 느려집니다. 해쉬 조인시 주의사항?


                             1. 작은 테이블이 메모리로 올라가게 힌트를 주면 됩니다.
                             2. 대용량일 경우에는 hash 테이블사용! 

64.아래의 SQL을 튜닝하는데 해쉬 조인되게 하고 emp 테이블이 메모리로 올라가서 hash 테이블이 되게하세요.
                                       ↓

select /*+ gather_plan_statistics  leading(e d) use_hash(d)*/ 
e.ename,d.loc
from emp e,dept d 
where e.deptno=d.deptno;

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));


65.직업이 SALESMAN 인 사원들의 이름과 월급과 comm2 를 출력하시오!
(emp 와 bonus 테이블을 조인하세요! ) 

select e.ename,e.sal,b.comm2
from emp e,bonus b
where e.empno=b.empno and e.job='SALESMAN';

66.위의 SQL의 실행계획을 아래와 같이나오게하시오!

조인순서 : emp----bonus 
                     ↓
                해쉬조인

select /*+ gather_plan_statistics  leading(e b) use_hash(b)*/ e.ename,e.sal,b.comm2
from emp ,e bonus b 
where e.empno=b.empno and e.job='SALESMAN';


select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));


설명 : 버퍼의 개수 8개 

e.job='SALESMAN'; 
설명: 위와 같이 emp와 bonus 둘다 14건으로 둘중 작은 테이블이 없다면 
        조건에 의해서 걸러지는 데이터가 작은것을 메모리로 올리면 됩니다.

직업이 SALESMAN인 사원들의 데이터가 4건이므로 4건만 메모리로 올리고 Bonus 와 조인하면 됩니다!! 앙기모띠~!! 


67.아래의 조인문장의 조인순서와 조인 방법을 직접 결정하시오(조인방법은 Hash 조인으로 하시오!!)


select /*+ gather_plan_statistics leading(D E) use_hash(E)*/ e.ename,d.loc
from emp e, dept d
where e.deptno=d.deptno
and e.job='SALESMAN'
and d.loc='CHICAGO';

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));

salesman 은 4개이고 // CHICAGO 는 1이기 때문에  순서를 dept로간다.!!

68.emp 와 dept 와 bonus 를 조인해서 이름과 부서위치와 comm2를 출력하시오!  총3개

보너스 테이블 생성해주고,

select e.ename,d.loc,b.comm2
from emp e , dept d, bonus b

where e.empno=b.empno and d.deptno=e.deptno;

69.위의 SQL의 조인순서와 조인방법을 아래와 같이 하시오!

조인 순서 : dept ---- emp ----bonus

                    해쉬조인   해쉬조인

select/* + gather_plan_statistics leading( d e b) use_hash(e) use_hash(b)*/
e.ename,d.loc,b.comm2
from emp e, dept d ,bonus b
where e.empno=b.empno and d.deptno=e.deptno;

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));

3-4 먼저 해쉬조인하고 
5랑 3-4 조인한거 다시 해쉬조인한게 1이다 
그리고 맨마지막 select 로올라가는거! 

설명 : dept 와 emp와 hash join 하고 그리고 두개를 해쉬조인한 결과와 보너스와 
해쉬조인했다.

3번에 있는게 hash 테이블이고  
4번은 probe 테이블이 된다.
5번 보너스도 probe 테이블이 된다 이말씀!

hash 테이블이 된다 이 두개를 조인한 결과가 해쉬테이블이 되고 해쉬테이블은
메모리로 올라가는것이다. 

70.위의 SQL의 실행계획을 아래와 같이 나오게 하시오! 

select/* + gather_plan_statistics leading( d e b) use_hash(e) use_hash(b) swap_join_inputs(b)*/
e.ename,d.loc,b.comm2
from emp e, dept d ,bonus b
where e.empno=b.empno and d.deptno=e.deptno;

select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));


힌트 : Swap_join_inputs : hash table 을 결정하는 힌트
        no_swap_join_inputs : probe table을 결정하는 힌트

2개의 테이블을 조인할때 hash table을 결정하는것은 leading 힌트만으로도 가능했는데
3개 이상의 테이블을 조인할 때 hash table을 결정할 때는
leading 으로는 제어가 안되고 swap_join_inputs 를 사용합니다. 

71.아래와 같이 실행계획이 나오게 하시오! 

select /*+ gather_plan_statistics  leading(b e d)
             use_hash(e)  use_hash(d)  swap_join_inputs(d) */  
   e.ename,  d.loc,  b.comm2
  from   emp  e,  dept  d, bonus  b
  where  e.deptno = d.deptno   and  e.empno = b.empno;

설명: bonus 테이블과 emp 와 해쉬조인을 먼저하고 이 해쉬조인한 결과와 dept와 해쉬조인을 하는데 dept 를 메모리로 올려서 해쉬테이블로 구성하고 해쉬조인을 수행했다.
3개의 테이블을 조인하려는 것이고 dept 테이블을 메모리로 올리기 위해서 swap_join_inputs 라는 힌트를 사용했습니다. 

이3개 알면 다 휘두를수 있다. 악성 SQL 과 칼을 휘두르며 싸우는 꼴..

*swap_join_inputs  해쉬조인때만 사용할 수 있습니다. 

72.emp와 salgrade 테이블을 조인해서 이름과 월급과 급여등급을 출력하고 hash 조인으로 유도하시오.

select/*+ gather_plan_statistics leading(s e) use_hash(e)*/ e.ename,e.sal,s.grade
from emp e ,salgrade s 
where e.sal between s.losal and s.hisal;

이것은 hash 조인이 안된다…

설명: 위의SQL을 실행계획이 hash join으로 풀리지 않습니다.
왜냐하면 해쉬조인이 되려면 where 절의 조인 조건이 이퀄(=)이어야
됩니다. non equi join은 해쉬조인으로 수행되지 않습니다. 

그렇다면 위와 같은 SQL의 2개 테이블이 둘다 대용량인데 해쉬조인을 못쓰면 어떻게튜닝을 해야하는가?

sort merge join 을 사용하면 됩니다.

	▪ Sort merge join 

조인하려는 데이터의 양이 많으면서 조인조건이 = 이 아닐때
검색능을 높이기 위한 조인방법

그래서 sort merge 조인 수행하면 연결고리가 되는 키 컬럼(deptno)를 정렬해놓고 
조인을 합니다.

예제
select /*+ gather_plan_statistics leading(d e) use_merge(e) */
e.ename,d.loc,e.deptno
from emp e,dept d
where e.deptno=d.deptno

결과를 보면 order by 절을 사용 하지 않았는데 deptno 가 정렬이 되어있습니다.
그 얘기는 sort merge join 가 deptno를 정렬해 놓고 조인을 수행했다는 것의 증거.
아래와 같이 데이터를 모아놨으므로 조인이 빨라집니다.

e.deptno =e.detpno 

where deptno =deptno 
            10          10
            20           10
            30           10
            40           20  
                          20
                          20 

---merge 의 장점이다.----

73.그러면 아래의 SQL 의 실행계획이 sort merge 조인이 되게 하시오

select /*+ gather_plan_statistics leading(s e) use_merge(e) */
e.ename,e.sal,s.grade
from emp e, salgrade s
where e.sal between s.losal and s.hisal
